<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Inventory Comparison</title>

  <style>
    body { font-family: system-ui; padding: 16px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px; }
    th { background: #f3f3f3; vertical-align: middle; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 14px; align-items: center; }
    input, select, button { padding: 6px; }
    .num { text-align: center; white-space: nowrap; }
    .mode { display: flex; align-items: center; gap: 6px; }
    .th-btn {
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }
    .sort-ind { font-size: 11px; opacity: 0.7; }
    .filter-row th { background: #fafafa; }
    .filter-input {
      width: 100%;
      box-sizing: border-box;
      padding: 5px;
    }
    .muted { color: #666; font-size: 12px; }

    /* Keep SKU from wrapping and keep a usable width */
    th.col-sku, td.col-sku {
      white-space: nowrap;
      word-break: normal;
      overflow-wrap: normal;
      min-width: 160px; /* tweak to taste */
    }

    /* Stacked inventory header lines */
    .th-stack {
      line-height: 1.05;
      text-align: center;
      white-space: nowrap;
    }
    .th-stack .l1 { font-weight: 700; }
    .th-stack .l2 { font-weight: 600; font-size: 12px; opacity: 0.9; }
    .th-stack .l3 { font-weight: 600; font-size: 12px; opacity: 0.9; }

    /* Sticky header */
    thead th {
      position: sticky;
      top: 0;
      z-index: 3;
      background: #f3f3f3;
    }
    .filter-row th {
      position: sticky;
      top: 38px; /* adjust if needed */
      z-index: 2;
      background: #fafafa;
    }

    /* Active filter styling (very obvious) */
    .filter-input.active-filter {
      outline: 2px solid #2563eb;
      background: #eff6ff;
    }
    th.has-filter {
      background: #fff7ed !important; /* light amber */
    }
    .filter-badge {
      margin-left: 6px;
      font-size: 12px;
      opacity: 0.85;
    }
  </style>
</head>

<body>

<h2>Inventory Comparison</h2>

<div class="row">
  <select id="snapshots"></select>

  <label class="mode">
    <input type="radio" name="compareMode" value="onHand" checked />
    On Hand
  </label>

  <label class="mode">
    <input type="radio" name="compareMode" value="available" />
    Available to Sell
  </label>

  <label class="mode">
    <input type="checkbox" id="onlyDiff" />
    Only show differences
  </label>

  <button id="clearFilters">Clear Filters</button>
  <button id="export">Export CSV</button>
  <span id="exportStatus"></span>
</div>

<div id="meta" class="muted"></div>

<!-- Scroll container so sticky headers behave consistently -->
<div style="overflow:auto; max-height: 70vh;">
  <table>
    <thead id="thead"></thead>
    <tbody id="rows"></tbody>
  </table>
</div>

<script>
const API_BASE = "/api";

let page = 1;
const pageSize = 100;

let sortField = "";   // will default to Diff_OH / Diff_ATS based on mode
let sortDir = "desc";

let dynamicInvKeys = [];   // union of Inventory[0] keys across returned rows (page)
let visibleColumns = [];   // rendered columns (base + inv keys in stable order)

/* Persist filters between rerenders + mode toggles */
const filters = {
  brand: "",
  season: "",
  style: "",
  sku: ""
};

/* Helps prevent Safari/pageshow from resurrecting filter values right after clearing */
let justCleared = false;

function debounce(fn, ms) {
  let t;
  return function() {
    clearTimeout(t);
    const args = arguments;
    t = setTimeout(() => fn.apply(null, args), ms);
  };
}

function getCompareMode() {
  const el = document.querySelector('input[name="compareMode"]:checked');
  return el ? el.value : "onHand";
}

function getDiffKeyForMode(mode) {
  return mode === "available" ? "Diff_ATS" : "Diff_OH";
}

function normalizeRow(r) {
  // Accept either Brand/Season/Style/SKU casing OR legacy casing if it sneaks in.
  const inv0 = (r && r.Inventory && r.Inventory.length) ? r.Inventory[0] : (r && r.inventory && r.inventory.length ? r.inventory[0] : {});
  return {
    brand: r.Brand || r.brand || "",
    season: r.Season || r.season || "",
    style: r.Style || r.style || "",
    sku: r.SKU || r.sku || "",
    inv: inv0 || {}
  };
}

function escapeHtml(s) {
  return String(s == null ? "" : s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function toNumberOrNull(v) {
  if (v === null || v === undefined || v === "") return null;
  const n = Number(v);
  return isNaN(n) ? null : n;
}

/* Turns:
   "Ashworth B2B On Hand" -> Ashworth / B2B / On-Hand
*/
function getStackedHeaderParts(label, mode) {
  const s = String(label || "");
  const metric = (mode === "available") ? "ATS" : "On Hand";

  // Diff columns: show Diff + metric
  if (s === "Diff_OH" || s === "Diff_ATS") {
    return {
      l1: "Diff",
      l2: "",
      l3: (mode === "available") ? "ATS" : "On-Hand"
    };
  }

  const metricPos = s.indexOf(metric);
  if (metricPos >= 0) {
    const left = s.substring(0, metricPos).trim();      // e.g. "Ashworth B2B"
    const right = s.substring(metricPos).trim();        // e.g. "On Hand" or "ATS"
    const leftParts = left.split(/\s+/);

    return {
      l1: leftParts[0] || s,
      l2: leftParts.slice(1).join(" ") || "",
      l3: right.replace("On Hand", "On-Hand")
    };
  }

  return { l1: s, l2: "", l3: "" };
}

function renderHeaderLabel(colLabel, mode) {
  // Base columns stay one-line.
  if (colLabel === "Brand" || colLabel === "Season" || colLabel === "Style" || colLabel === "SKU") {
    return escapeHtml(colLabel);
  }

  // Inventory columns -> stacked
  const p = getStackedHeaderParts(colLabel, mode);
  return (
    '<div class="th-stack">' +
      '<div class="l1">' + escapeHtml(p.l1) + '</div>' +
      (p.l2 ? '<div class="l2">' + escapeHtml(p.l2) + '</div>' : '<div class="l2"></div>') +
      (p.l3 ? '<div class="l3">' + escapeHtml(p.l3) + '</div>' : '<div class="l3"></div>') +
    '</div>'
  );
}

function buildColumnsFromRows(rowsNormalized) {
  const mode = getCompareMode();              // "onHand" or "available"
  const diffKey = getDiffKeyForMode(mode);    // "Diff_OH" or "Diff_ATS"

  // Union keys across the current pageâ€™s inventory objects
  const keySet = {};
  rowsNormalized.forEach(r => {
    const inv = r.inv || {};
    Object.keys(inv).forEach(k => { keySet[k] = true; });
  });

  function keyMatchesMode(k) {
    const kk = String(k || "");

    const isDiff = (kk === "Diff_OH" || kk === "Diff_ATS");
    if (isDiff) return kk === diffKey;

    const hasOnHand = kk.indexOf("On Hand") >= 0;
    const hasATS = kk.indexOf("ATS") >= 0;

    if (mode === "available") return hasATS;
    return hasOnHand;
  }

  const allKeys = Object.keys(keySet).filter(keyMatchesMode);

  // Stable ordering: totals + diff first, then the rest alphabetical
  const preferredOrderOnHand = [
    "NetSuite Total On Hand",
    "Snap Total On Hand",
    "Diff_OH"
  ];

  const preferredOrderATS = [
    "NetSuite Total ATS",
    "Snap Total ATS",
    "Diff_ATS"
  ];

  const preferredOrder = (mode === "available") ? preferredOrderATS : preferredOrderOnHand;

  const preferred = [];
  preferredOrder.forEach(k => {
    if (allKeys.indexOf(k) >= 0) preferred.push(k);
  });

  const remaining = allKeys.filter(k => preferred.indexOf(k) === -1);
  remaining.sort(function(a,b){ return a.localeCompare(b); });

  dynamicInvKeys = preferred.concat(remaining);

  visibleColumns = [
    { key: "brand", label: "Brand", sortKey: "brand" },
    { key: "season", label: "Season", sortKey: "season" },
    { key: "style", label: "Style", sortKey: "style" },
    { key: "sku", label: "SKU", sortKey: "sku", thClass: "col-sku" }
  ];

  dynamicInvKeys.forEach(k => {
    visibleColumns.push({ key: k, label: k, sortKey: k });
  });
}

function updateSortIndicators() {
  visibleColumns.forEach(col => {
    const el = document.getElementById("si-" + col.sortKey);
    if (!el) return;
    el.textContent = (sortField === col.sortKey) ? (sortDir === "asc" ? "â–²" : "â–¼") : "";
  });
}

function setSort(field) {
  if (sortField === field) {
    sortDir = sortDir === "asc" ? "desc" : "asc";
  } else {
    sortField = field;
    sortDir = "desc";
  }
  page = 1;
  updateSortIndicators();
  loadRows();
}

function applyFilterStyling() {
  const mapping = [
    { id: "fBrand", key: "brand", thKey: "brand" },
    { id: "fSeason", key: "season", thKey: "season" },
    { id: "fStyle", key: "style", thKey: "style" },
    { id: "fSku", key: "sku", thKey: "sku" }
  ];

  mapping.forEach(m => {
    const input = document.getElementById(m.id);
    const th = document.getElementById("th-" + m.thKey);
    const active = String(filters[m.key] || "").trim().length > 0;

    if (input) input.classList.toggle("active-filter", active);
    if (th) th.classList.toggle("has-filter", active);
  });
}

function clearAllFilters() {
  justCleared = true;
  setTimeout(() => { justCleared = false; }, 600);

  filters.brand = "";
  filters.season = "";
  filters.style = "";
  filters.sku = "";

  // clear DOM immediately (if inputs exist)
  ["fBrand","fSeason","fStyle","fSku"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = "";
  });

  applyFilterStyling();

  page = 1;
  loadRows();
}

function renderHeader() {
  const thead = document.getElementById("thead");
  thead.innerHTML = "";

  const mode = getCompareMode();

  // Row 1: headers + sort + filter badge
  const tr1 = document.createElement("tr");

  visibleColumns.forEach(col => {
    const th = document.createElement("th");
    if (col.thClass) th.className = col.thClass;

    const isBase = (col.key === "brand" || col.key === "season" || col.key === "style" || col.key === "sku");
    if (isBase) th.id = "th-" + col.key;

    // Determine if this base column has an active filter
    let isFiltered = false;
    if (col.key === "brand") isFiltered = String(filters.brand || "").trim().length > 0;
    else if (col.key === "season") isFiltered = String(filters.season || "").trim().length > 0;
    else if (col.key === "style") isFiltered = String(filters.style || "").trim().length > 0;
    else if (col.key === "sku") isFiltered = String(filters.sku || "").trim().length > 0;

    const badge = (isBase && isFiltered) ? `<span class="filter-badge">ðŸ”Ž</span>` : "";

    th.innerHTML =
      `<span class="th-btn" data-sort="${escapeHtml(col.sortKey)}">` +
        `${renderHeaderLabel(col.label, mode)}${badge} ` +
        `<span id="si-${escapeHtml(col.sortKey)}" class="sort-ind"></span>` +
      `</span>`;

    tr1.appendChild(th);
  });

  thead.appendChild(tr1);

  // Row 2: filters (base columns only)
  const tr2 = document.createElement("tr");
  tr2.className = "filter-row";

  visibleColumns.forEach(col => {
    const th = document.createElement("th");
    if (col.thClass) th.className = col.thClass;

    if (col.key === "brand") th.innerHTML = `<input id="fBrand" name="fBrand" autocomplete="off" class="filter-input" placeholder="Filter brandâ€¦" />`;
    else if (col.key === "season") th.innerHTML = `<input id="fSeason" name="fSeason" autocomplete="off" class="filter-input" placeholder="Filter seasonâ€¦" />`;
    else if (col.key === "style") th.innerHTML = `<input id="fStyle" name="fStyle" autocomplete="off" class="filter-input" placeholder="Filter styleâ€¦" />`;
    else if (col.key === "sku") th.innerHTML = `<input id="fSku" name="fSku" autocomplete="off" class="filter-input" placeholder="Filter SKUâ€¦" />`;
    else th.innerHTML = "";

    tr2.appendChild(th);
  });

  thead.appendChild(tr2);

  // Wire sort clicks
  thead.querySelectorAll(".th-btn").forEach(el => {
    el.addEventListener("click", () => setSort(el.getAttribute("data-sort")));
  });

  // Rehydrate filter input values from persisted filters object
  if (document.getElementById("fBrand")) document.getElementById("fBrand").value = filters.brand;
  if (document.getElementById("fSeason")) document.getElementById("fSeason").value = filters.season;
  if (document.getElementById("fStyle")) document.getElementById("fStyle").value = filters.style;
  if (document.getElementById("fSku")) document.getElementById("fSku").value = filters.sku;

  // Wire filter events (update persisted filters + reload)
  const onFilterChange = debounce(() => {
    filters.brand = (document.getElementById("fBrand") && document.getElementById("fBrand").value) || "";
    filters.season = (document.getElementById("fSeason") && document.getElementById("fSeason").value) || "";
    filters.style = (document.getElementById("fStyle") && document.getElementById("fStyle").value) || "";
    filters.sku = (document.getElementById("fSku") && document.getElementById("fSku").value) || "";

    page = 1;
    loadRows();
  }, 250);

  ["fBrand","fSeason","fStyle","fSku"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("input", onFilterChange);
  });

  updateSortIndicators();
  applyFilterStyling();
}

async function loadSnapshots() {
  const res = await fetch(`${API_BASE}/snapshots`);
  const data = await res.json();
  const sel = document.getElementById("snapshots");
  sel.innerHTML = "";

  if (data && data.length) {
    data.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.snapshotId;
      opt.textContent = `${new Date(s.snapshotDate).toLocaleDateString()} (${s.rowCount})`;
      sel.appendChild(opt);
    });
  } else {
    const opt = document.createElement("option");
    opt.textContent = "No snapshots found";
    sel.appendChild(opt);
  }
}

async function loadRows() {
  const snapshotId = document.getElementById("snapshots").value;
  if (!snapshotId) return;

  const mode = getCompareMode();
  const diffKey = getDiffKeyForMode(mode);

  // Default sort to the right diff key if unset or if it was the other modeâ€™s diff
  if (!sortField || sortField === "Diff_OH" || sortField === "Diff_ATS") {
    sortField = diffKey;
  }

  const onlyDiff = document.getElementById("onlyDiff").checked ? "1" : "0";

  const qs = new URLSearchParams({
    page,
    pageSize,
    brand: filters.brand,
    season: filters.season,
    style: filters.style,
    sku: filters.sku,
    compareMode: mode,
    sort: `${sortField}_${sortDir}`,
    onlyDiff
  });

  qs.set("format", "new");

  const res = await fetch(`${API_BASE}/snapshots/${snapshotId}/rows?` + qs.toString());
  const data = await res.json();

  let rowsNormalized = (data.rows || []).map(normalizeRow);

  // Client-side "only differences" filter (backend may or may not implement)
  if (document.getElementById("onlyDiff").checked) {
    rowsNormalized = rowsNormalized.filter(r => {
      const v = (r.inv && r.inv[diffKey]) != null ? Number(r.inv[diffKey]) : 0;
      return v !== 0;
    });
  }

  buildColumnsFromRows(rowsNormalized);
  renderHeader();

  document.getElementById("meta").textContent =
    `Total rows: ${data.total} | Sort: ${sortField}_${sortDir} | Mode: ${mode} | Diff field: ${diffKey}`;

  const tbody = document.getElementById("rows");
  tbody.innerHTML = "";

  rowsNormalized.forEach(r => {
    const inv = r.inv || {};
    const tr = document.createElement("tr");

    let html = "";
    html += `<td>${escapeHtml(r.brand)}</td>`;
    html += `<td>${escapeHtml(r.season)}</td>`;
    html += `<td>${escapeHtml(r.style)}</td>`;
    html += `<td class="col-sku">${escapeHtml(r.sku)}</td>`;

    dynamicInvKeys.forEach(k => {
      const v = inv[k];
      const isDiffCol = (k === "Diff_OH" || k === "Diff_ATS");
      const n = toNumberOrNull(v);

      if (isDiffCol) {
        const dv = (toNumberOrNull(v) ?? 0);
        const c = dv === 0 ? "#15803d" : (dv > 0 ? "#b45309" : "#b91c1c");
        html += `<td class="num" style="font-weight:700;color:${c};">${escapeHtml(dv)}</td>`;
      } else if (n !== null) {
        html += `<td class="num">${escapeHtml(n)}</td>`;
      } else {
        html += `<td>${escapeHtml(v)}</td>`;
      }
    });

    tr.innerHTML = html;
    tbody.appendChild(tr);
  });

  applyFilterStyling();
}

window.addEventListener("pageshow", () => {
  if (justCleared) return;

  // If browser restores inputs, sync DOM -> filters, then style
  const b = document.getElementById("fBrand");
  const s = document.getElementById("fSeason");
  const st = document.getElementById("fStyle");
  const k = document.getElementById("fSku");

  if (b || s || st || k) {
    filters.brand = (b && b.value) || filters.brand || "";
    filters.season = (s && s.value) || filters.season || "";
    filters.style = (st && st.value) || filters.style || "";
    filters.sku = (k && k.value) || filters.sku || "";
    applyFilterStyling();
  }
});

async function exportCsv() {
  const snapshotId = document.getElementById("snapshots").value;
  if (!snapshotId) return;

  const onlyDiff = document.getElementById("onlyDiff").checked ? "1" : "0";

  const qs = new URLSearchParams({
    snapshotId,
    brand: filters.brand,
    season: filters.season,
    style: filters.style,
    sku: filters.sku,
    compareMode: getCompareMode(),
    sort: `${sortField}_${sortDir}`,
    onlyDiff
  });

  qs.set("format", "new");

  const res = await fetch(`${API_BASE}/export?` + qs.toString());
  const blob = await res.blob();

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `inventory-export-${getCompareMode()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

document.getElementById("clearFilters").addEventListener("click", clearAllFilters);
document.getElementById("export").addEventListener("click", exportCsv);
document.getElementById("snapshots").addEventListener("change", () => { page = 1; loadRows(); });
document.getElementById("onlyDiff").addEventListener("change", () => { page = 1; loadRows(); });

document.querySelectorAll('input[name="compareMode"]').forEach(r => {
  r.addEventListener("change", () => { page = 1; loadRows(); });
});

(async () => {
  await loadSnapshots();
  await loadRows();
})();
</script>

</body>
</html>