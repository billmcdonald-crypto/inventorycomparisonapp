<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Inventory Comparison</title>

  <style>
    body { font-family: system-ui; padding: 16px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 6px; }
    th { background: #f3f3f3; vertical-align: middle; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 14px; align-items: center; }
    input, select, button { padding: 6px; }
    .num { text-align: center; white-space: nowrap; }
    .mode { display: flex; align-items: center; gap: 6px; }
    .th-btn {
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      gap: 6px;
      align-items: center;
      white-space: nowrap;
    }
    .sort-ind { font-size: 11px; opacity: 0.7; }
    .filter-row th { background: #fafafa; }
    .filter-input {
      width: 100%;
      box-sizing: border-box;
      padding: 5px;
    }
    .muted { color: #666; font-size: 12px; }
  </style>
</head>

<body>

<h2>Inventory Comparison</h2>

<div class="row">
  <select id="snapshots"></select>

  <label class="mode">
    <input type="radio" name="compareMode" value="onHand" checked />
    On Hand
  </label>

  <label class="mode">
    <input type="radio" name="compareMode" value="available" />
    Available to Sell
  </label>

  <label class="mode">
    <input type="checkbox" id="onlyDiff" />
    Only show differences
  </label>

  <button id="refresh">Refresh</button>
  <button id="clearFilters">Clear Filters</button>
  <button id="export">Export CSV</button>
  <span id="exportStatus"></span>
</div>

<div id="meta" class="muted"></div>

<table>
  <thead id="thead"></thead>
  <tbody id="rows"></tbody>
</table>

<script>
const API_BASE = "/api";

let page = 1;
const pageSize = 100;

let sortField = "";   // will default to Diff_OH / Diff_ATS based on mode
let sortDir = "desc";

let dynamicInvKeys = [];   // union of Inventory[0] keys across returned rows (page)
let visibleColumns = [];   // rendered columns (base + inv keys in stable order)

function debounce(fn, ms) {
  let t;
  return function() {
    clearTimeout(t);
    t = setTimeout(() => fn(), ms);
  };
}

function getCompareMode() {
  const el = document.querySelector('input[name="compareMode"]:checked');
  return el ? el.value : "onHand";
}

function getDiffKeyForMode(mode) {
  return mode === "available" ? "Diff_ATS" : "Diff_OH";
}

function normalizeRow(r) {
  // Accept either Brand/Season/Style/SKU casing OR legacy casing if it sneaks in.
  const inv0 = (r && r.Inventory && r.Inventory.length) ? r.Inventory[0] : (r && r.inventory && r.inventory.length ? r.inventory[0] : {});
  return {
    brand: r.Brand || r.brand || "",
    season: r.Season || r.season || "",
    style: r.Style || r.style || "",
    sku: r.SKU || r.sku || "",
    inv: inv0 || {}
  };
}

function escapeHtml(s) {
  return String(s == null ? "" : s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function toNumberOrNull(v) {
  if (v === null || v === undefined || v === "") return null;
  const n = Number(v);
  return isNaN(n) ? null : n;
}

function buildColumnsFromRows(rowsNormalized) {
  const mode = getCompareMode();              // "onHand" or "available"
  const diffKey = getDiffKeyForMode(mode);    // "Diff_OH" or "Diff_ATS"

  // Union keys across the current page’s inventory objects
  const keySet = {};
  rowsNormalized.forEach(r => {
    const inv = r.inv || {};
    Object.keys(inv).forEach(k => { keySet[k] = true; });
  });

  // Decide which inventory keys to show based on mode.
  // OnHand: show "*On Hand*" keys + Diff_OH (and hide ATS stuff)
  // Available: show "*ATS*" keys + Diff_ATS (and hide On Hand stuff)
  function keyMatchesMode(k) {
    const kk = String(k || "");

    const isDiff = (kk === "Diff_OH" || kk === "Diff_ATS");
    if (isDiff) return kk === diffKey;

    const hasOnHand = kk.indexOf("On Hand") >= 0;
    const hasATS = kk.indexOf("ATS") >= 0;

    if (mode === "available") {
      // show ATS columns (plus totals ATS)
      return hasATS;
    } else {
      // show On Hand columns (plus totals On Hand)
      return hasOnHand;
    }
  }

  const allKeys = Object.keys(keySet).filter(keyMatchesMode);

  // Stable ordering: totals + diff first, then the rest alphabetical
  const preferredOrderOnHand = [
    "NetSuite Total On Hand",
    "Snap Total On Hand",
    "Diff_OH"
  ];

  const preferredOrderATS = [
    "NetSuite Total ATS",
    "Snap Total ATS",
    "Diff_ATS"
  ];

  const preferredOrder = (mode === "available") ? preferredOrderATS : preferredOrderOnHand;

  const preferred = [];
  preferredOrder.forEach(k => {
    if (allKeys.indexOf(k) >= 0) preferred.push(k);
  });

  const remaining = allKeys.filter(k => preferred.indexOf(k) === -1);
  remaining.sort(function(a,b){ return a.localeCompare(b); });

  dynamicInvKeys = preferred.concat(remaining);

  visibleColumns = [
    { key: "brand", label: "Brand", sortKey: "brand" },
    { key: "season", label: "Season", sortKey: "season" },
    { key: "style", label: "Style", sortKey: "style" },
    { key: "sku", label: "SKU", sortKey: "sku" }
  ];

  dynamicInvKeys.forEach(k => {
    visibleColumns.push({ key: k, label: k, sortKey: k });
  });
}

function updateSortIndicators() {
  visibleColumns.forEach(col => {
    const el = document.getElementById("si-" + col.sortKey);
    if (!el) return;
    el.textContent = (sortField === col.sortKey) ? (sortDir === "asc" ? "▲" : "▼") : "";
  });
}

function setSort(field) {
  if (sortField === field) {
    sortDir = sortDir === "asc" ? "desc" : "asc";
  } else {
    sortField = field;
    sortDir = "desc";
  }
  page = 1;
  updateSortIndicators();
  loadRows();
}

function clearAllFilters() {
  document.getElementById("fBrand").value = "";
  document.getElementById("fSeason").value = "";
  document.getElementById("fStyle").value = "";
  document.getElementById("fSku").value = "";
  page = 1;
  loadRows();
}

function renderHeader() {
  const thead = document.getElementById("thead");
  thead.innerHTML = "";

  const tr1 = document.createElement("tr");

  visibleColumns.forEach(col => {
    const th = document.createElement("th");
    th.innerHTML =
      `<span class="th-btn" data-sort="${escapeHtml(col.sortKey)}">${escapeHtml(col.label)} <span id="si-${escapeHtml(col.sortKey)}" class="sort-ind"></span></span>`;
    tr1.appendChild(th);
  });

  thead.appendChild(tr1);

  // Filter row: only for base fields (Brand/Season/Style/SKU)
  const tr2 = document.createElement("tr");
  tr2.className = "filter-row";

  visibleColumns.forEach(col => {
    const th = document.createElement("th");
    if (col.key === "brand") th.innerHTML = `<input id="fBrand" class="filter-input" placeholder="Filter brand…" />`;
    else if (col.key === "season") th.innerHTML = `<input id="fSeason" class="filter-input" placeholder="Filter season…" />`;
    else if (col.key === "style") th.innerHTML = `<input id="fStyle" class="filter-input" placeholder="Filter style…" />`;
    else if (col.key === "sku") th.innerHTML = `<input id="fSku" class="filter-input" placeholder="Filter SKU…" />`;
    else th.innerHTML = "";
    tr2.appendChild(th);
  });

  thead.appendChild(tr2);

  // Wire sort clicks
  thead.querySelectorAll(".th-btn").forEach(el => {
    el.addEventListener("click", () => setSort(el.getAttribute("data-sort")));
  });

  // Wire filter events
  const onFilterChange = debounce(() => { page = 1; loadRows(); }, 250);
  ["fBrand","fSeason","fStyle","fSku"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener("input", onFilterChange);
  });

  updateSortIndicators();
}

async function loadSnapshots() {
  const res = await fetch(`${API_BASE}/snapshots`);
  const data = await res.json();
  const sel = document.getElementById("snapshots");
  sel.innerHTML = "";

  if (data && data.length) {
    data.forEach(s => {
      const opt = document.createElement("option");
      opt.value = s.snapshotId;
      opt.textContent = `${new Date(s.snapshotDate).toLocaleDateString()} (${s.rowCount})`;
      sel.appendChild(opt);
    });
  } else {
    const opt = document.createElement("option");
    opt.textContent = "No snapshots found";
    sel.appendChild(opt);
  }
}

async function loadRows() {
  const snapshotId = document.getElementById("snapshots").value;
  if (!snapshotId) return;

  const mode = getCompareMode();
  const diffKey = getDiffKeyForMode(mode);

  // Default sort to the right diff key if unset or if it was the other mode’s diff
  if (!sortField || sortField === "Diff_OH" || sortField === "Diff_ATS") {
    sortField = diffKey;
  }

  // Updated filters (client sends them; backend can ignore extras if not implemented yet)
  const brand = (document.getElementById("fBrand") && document.getElementById("fBrand").value) || "";
  const season = (document.getElementById("fSeason") && document.getElementById("fSeason").value) || "";
  const style = (document.getElementById("fStyle") && document.getElementById("fStyle").value) || "";
  const sku = (document.getElementById("fSku") && document.getElementById("fSku").value) || "";

  const onlyDiff = document.getElementById("onlyDiff").checked ? "1" : "0";

  const qs = new URLSearchParams({
    page,
    pageSize,

    // New-ish filters
    brand,
    season,
    style,
    sku,

    // Keep existing API contract knobs
    compareMode: mode,
    sort: `${sortField}_${sortDir}`,
    onlyDiff
  });

  qs.set("format", "new");

  const res = await fetch(`${API_BASE}/snapshots/${snapshotId}/rows?` + qs.toString());
  const data = await res.json();  

  let rowsNormalized = (data.rows || []).map(normalizeRow);

  // Client-side "only differences" filter (backend doesn't implement it yet)
if (document.getElementById("onlyDiff").checked) {
  const mode = getCompareMode();
  const diffKey = getDiffKeyForMode(mode);

  rowsNormalized = rowsNormalized.filter(r => {
    const v = (r.inv && r.inv[diffKey]) != null ? Number(r.inv[diffKey]) : 0;
    return v !== 0;
  });
}

  // Build dynamic columns from the returned rows, then render header.
  buildColumnsFromRows(rowsNormalized);
  renderHeader();

  document.getElementById("meta").textContent =
    `Total rows: ${data.total} | Sort: ${sortField}_${sortDir} | Mode: ${mode} | Diff field: ${diffKey}`;

  const tbody = document.getElementById("rows");
  tbody.innerHTML = "";

  rowsNormalized.forEach(r => {
    const inv = r.inv || {};
    const diffValRaw = inv[diffKey];
    const diffVal = toNumberOrNull(diffValRaw) ?? 0;

    const diffColor = diffVal === 0 ? "#15803d" : (diffVal > 0 ? "#b45309" : "#b91c1c");

    const tr = document.createElement("tr");

    // Base columns
    let html = "";
    html += `<td>${escapeHtml(r.brand)}</td>`;
    html += `<td>${escapeHtml(r.season)}</td>`;
    html += `<td>${escapeHtml(r.style)}</td>`;
    html += `<td>${escapeHtml(r.sku)}</td>`;

    // Dynamic inventory columns
    dynamicInvKeys.forEach(k => {
      const v = inv[k];

      // numeric alignment, and special coloring for Diff_OH / Diff_ATS
      const isDiffCol = (k === "Diff_OH" || k === "Diff_ATS");
      const n = toNumberOrNull(v);

      if (isDiffCol) {
        const dv = (toNumberOrNull(v) ?? 0);
        const c = dv === 0 ? "#15803d" : (dv > 0 ? "#b45309" : "#b91c1c");
        html += `<td class="num" style="font-weight:700;color:${c};">${escapeHtml(dv)}</td>`;
      } else if (n !== null) {
        html += `<td class="num">${escapeHtml(n)}</td>`;
      } else {
        html += `<td>${escapeHtml(v)}</td>`;
      }
    });

    tr.innerHTML = html;

    // Optional: emphasize the “active mode” diff key cell slightly (purely visual)
    // (No extra DOM surgery; already colored.)

    tbody.appendChild(tr);
  });
}

async function exportCsv() {
  const snapshotId = document.getElementById("snapshots").value;
  if (!snapshotId) return;

  const brand = (document.getElementById("fBrand") && document.getElementById("fBrand").value) || "";
  const season = (document.getElementById("fSeason") && document.getElementById("fSeason").value) || "";
  const style = (document.getElementById("fStyle") && document.getElementById("fStyle").value) || "";
  const sku = (document.getElementById("fSku") && document.getElementById("fSku").value) || "";
  const onlyDiff = document.getElementById("onlyDiff").checked ? "1" : "0";

  const qs = new URLSearchParams({
    snapshotId,
    brand,
    season,
    style,
    sku,
    compareMode: getCompareMode(),
    sort: `${sortField}_${sortDir}`,
    onlyDiff
  });

  // This is the important addition:
  qs.set("format", "new");

  const res = await fetch(`${API_BASE}/export?` + qs.toString());
  const blob = await res.blob();

  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `inventory-export-${getCompareMode()}.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

document.getElementById("refresh").addEventListener("click", () => { page = 1; loadRows(); });
document.getElementById("clearFilters").addEventListener("click", clearAllFilters);
document.getElementById("export").addEventListener("click", exportCsv);
document.getElementById("snapshots").addEventListener("change", () => { page = 1; loadRows(); });
document.getElementById("onlyDiff").addEventListener("change", () => { page = 1; loadRows(); });

document.querySelectorAll('input[name="compareMode"]').forEach(r => {
  r.addEventListener("change", () => { page = 1; loadRows(); });
});

(async () => {
  await loadSnapshots();
  await loadRows();
})();
</script>

</body>
</html>